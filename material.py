import bpy
import yaml
import collections
import random
from . lookup_node_group import lookup_node_group
from . flowmap import flowmap, serialize
from . property_group import node_types
from . node_group import save_node_group

node_library = [element[1].lower() for element in node_types]

def load_material(source_file):
    with open(source_file, "r") as open_file:
        data = yaml.safe_load(open_file)

    material = bpy.data.materials.new(name = data["name"])
    material.use_nodes = True
    material.node_tree.nodes.remove(material.node_tree.nodes['Principled BSDF']) 

    nodes = dict()
    nodes["output"] = material.node_tree.nodes.get('Material Output')
    nodes["output"].location = data["output"]["loc"]

    for name, node_data in data["nodes"].items():
        if node_data["type"][:10] == "NodeGroup_":
            node = material.node_tree.nodes.new("ShaderNodeGroup")
            node.node_tree = lookup_node_group(node_data["type"][10:]+".yaml") #Possibly allow some node groups in library to be hidden, so they only appear as material dependencies?
        else:
            node = material.node_tree.nodes.new('ShaderNode'+node_data["type"])
        node.location = node_data["loc"]
        nodes[name] = node
        for option, value in node_data.items():
            if option not in ["type", "loc", "defaults"]:
                node.__setattr__(option, value)
            if option == "defaults":
                for param in value:
                    node.inputs[param[0]].default_value = param[1]

    for outgoing_link in data["links"]:
        material.node_tree.links.new(nodes[outgoing_link[0]].outputs[outgoing_link[1]], nodes[outgoing_link[2]].inputs[outgoing_link[3]])

    #options could theoretically be modeled as the inputs of node_groups in some kind of standardized node_tree markdown
    options = dict()
    if "options" in data.keys():
        for name, value in data["options"].items():
            options[name] = nodes[value[0]].inputs[value[1]]
            #options["name"] = nodes[value[0]].inputs[value[1]]
            #options["name"] = nodes[value[0]]
            #options["name"] = [nodes[value[0]], nodes[value[0]].inputs[value[1]].name]

    #postprocess is something unique to materials and not node groups
    postprocess = dict()
    if "postprocess" in data.keys():
        postprocess = data["postprocess"]

    return material, options, postprocess

def save_material(name, desc, material):
    data = dict()
    data["name"] = name
    data["desc"] = desc

    temporary_group = bpy.data.node_groups.new("Temporary", "ShaderNodeTree")

    nodes_table = dict()
    nodes_counter = collections.Counter()
    for node in material.nodes:
        if node.type == "OUTPUT_MATERIAL":
            data["output"] = {"loc":serialize(node.location)}
            nodes_table["output"] = node
        else:
            nodes_table[node.bl_idname[10:]+str(nodes_counter[node.bl_idname[10:]])] = node
            nodes_counter[node.bl_idname[10:]] += 1
    
    data["nodes"] = dict()
    for node in nodes_table:
        if node == "output": continue
        data["nodes"][node] = dict()
        data["nodes"][node]["type"] = nodes_table[node].bl_idname[10:]
        data["nodes"][node]["loc"] = serialize(nodes_table[node].location)
        if data["nodes"][node]["type"].lower() == "group":
            group_name = nodes_table[node].node_tree.name.lower()
            if group_name not in node_library:
                title = nodes_table[node].label
                if title == "": title = "autogenerated"+str(random.randint(0,99999)) #TODO: Manage this better... Have an index that counts up for each automatically generated title. Also, make any such autogenerated nodes hidden from the regular library.
                data["nodes"][node]["type"] = "NodeGroup_"+title
                save_node_group(title, "automatically generated by save material to library", nodes_table[node].node_tree)
                temporary_node = temporary_group.nodes.new("ShaderNodeGroup")
                temporary_node.node_tree = lookup_node_group(title+".yaml")
            else:
                data["nodes"][node]["type"] = "NodeGroup_"+group_name
                temporary_node = temporary_group.nodes.new("ShaderNodeGroup")
                temporary_node.node_tree = lookup_node_group(group_name+".yaml")
        else:
            temporary_node = temporary_group.nodes.new(type=nodes_table[node].bl_idname)
        special_attributes = [attribute for attribute in dir(nodes_table[node]) if nodes_table[node].__getattribute__(attribute) != temporary_node.__getattribute__(attribute)]
        for attribute in special_attributes:
            if attribute == "defaults": continue #Handled more comprehensively later on.
            if attribute == "select": continue
            if callable(nodes_table[node].__getattribute__(attribute)): continue
            try:
                yaml.safe_dump(nodes_table[node].__getattribute__(attribute))
                data["nodes"][node][attribute] = nodes_table[node].__getattribute__(attribute)
            except yaml.representer.RepresenterError: pass
        i = -1
        for input in nodes_table[node].inputs:
            i += 1
            if "default_value" not in dir(input): continue #Whatever these are, they don't have default values, and therefore do not concern this part of the program.
            if temporary_node.inputs[i].default_value == input.default_value: continue #Only need to record defaults that diverge from the regular ones.
            try:
                yaml.safe_dump(input.default_value)
                if "defaults" not in data["nodes"][node].keys(): data["nodes"][node]["defaults"] = []
                data["nodes"][node]["defaults"].append(serialize([i, input.default_value]))
            except yaml.representer.RepresenterError: #Quick way to identify if value can safely be serialized. Look into a better way to do this in the future.
                try:
                    val1 = list(input.default_value)
                    val2 = list(temporary_node.inputs[i].default_value)
                    if val1 == val2: continue
                    try:
                        yaml.safe_dump(val1)
                    except yaml.representer.RepresenterError: pass
                    if "defaults" not in data["nodes"][node].keys(): data["nodes"][node]["defaults"] = []
                    data["nodes"][node]["defaults"].append(flowmap([i, val1]))
                except TypeError: pass

    data["links"] = []
    for link in material.links: #This loop has more repeated code than I would like.
        entry = []
        for key in nodes_table.keys():
            if link.from_node == nodes_table[key]:
                entry.append(key)
        if len(entry) != 1: raise RuntimeError
        from_socket = 0
        for socket in link.from_node.outputs:
            if socket == link.from_socket: break
            from_socket += 1
        entry.append(from_socket)
        for key in nodes_table.keys():
            if link.to_node == nodes_table[key]:
                entry.append(key)
        if len(entry) != 3: raise RuntimeError
        to_socket = 0
        for socket in link.to_node.inputs:
            if socket == link.to_socket: break
            to_socket += 1
        entry.append(to_socket)
        data["links"].append(flowmap(entry))

    bpy.data.node_groups.remove(temporary_group)

    with open("materials/"+name.lower()+".yaml", "w") as open_file:
        yaml.dump(data, open_file, sort_keys=False)